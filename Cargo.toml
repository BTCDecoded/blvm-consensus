[package]
name = "blvm-consensus"
version = "0.1.6"
edition = "2021"
authors = ["Bitcoin Commons Team"]
description = "Bitcoin Commons BLVM: Direct mathematical implementation of Bitcoin consensus rules from the Orange Paper"
license = "MIT"
repository = "https://github.com/BTCDecoded/blvm-consensus"
homepage = "https://btcdecoded.org"
documentation = "https://docs.rs/blvm-consensus"
keywords = ["bitcoin", "consensus", "blockchain", "cryptocurrency", "proof"]
categories = ["cryptography::cryptocurrencies", "algorithms"]
rust-version = "1.83"

[lints.rust]
unexpected_cfgs = { level = "warn" }

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

[dependencies]
smallvec = { version = "1.11", optional = true, features = ["serde"] }

# Consensus-critical cryptography - EXACT VERSIONS
secp256k1 = "=0.28.2"
# Pure Rust secp256k1 implementation (Phase 3.2 - migration in progress)
k256 = { version = "=0.13", optional = true, features = ["ecdsa", "sha256"] }
# Enable SIMD optimizations for hashing
# The "asm" feature enables optimized assembly implementations
# Note: sha2-asm doesn't support Windows, so we use target-specific dependencies below
# sha2 is defined in target-specific sections only
ripemd = "=0.1.3"
sha1 = "=0.10.6"
bitcoin_hashes = "=0.11.0"

# Non-consensus-critical utilities - EXACT VERSIONS for supply chain security
serde = { version = "=1.0.228", features = ["derive"] }  # Updated for iroh 0.95 compatibility
serde_json = "=1.0.108"
anyhow = "=1.0.93"
thiserror = "=1.0.69"
# Binary serialization (for transaction/block encoding in differential tests)
bincode = "=1.3.3"
# Hex encoding (for RPC communication)
hex = "=0.4.3"
# Fast hash map for UTXO lookups (2-3x faster than std HashMap for fixed-size keys)
rustc-hash = { version = "2.0", optional = true }

# Spec-lock for mathematical verification
# Default: Use crate from crates.io (once published)
# Fallback: Git dependency (if crate not available, CI will clone repo)
# Local dev: Use .cargo/config.toml with [patch.crates-io] (see .cargo/config.toml.example)
# Version range allows compatible updates (^0.1.0 allows 0.1.x but not 0.2.x)
# Note: Constants are always available for property tests; #[spec_locked] attributes are metadata for formal verification
blvm-spec-lock = "^0.1.0"
# Spec-macros for spec_locked attributes (migration in progress - commented out until committed)
# blvm-spec-macros = { path = "../blvm-spec-macros", optional = true }


[dev-dependencies]
# Formal verification tools - EXACT VERSIONS for reproducibility
proptest = "=1.5.0"
# Fuzzing framework for better test coverage ergonomics
bolero = "0.11"
# HTTP client for differential fuzzing vs Bitcoin Core (Phase 2.2)
reqwest = { version = "0.11", features = ["json"], default-features = false }
# Async runtime for differential fuzzing tests
tokio = { version = "1.35", features = ["rt", "macros"] }
# Performance benchmarking framework
criterion = "0.5"

[features]
default = []
# Enable k256 (uses deprecated generic_array from elliptic_curve, will be fixed when k256 updates)
k256 = ["dep:k256"]

# Enable fuzzing tests (Bolero framework)
# Note: bolero is a dev-dependency, this feature is just for conditional compilation
# Users should use: cargo test --features bolero
bolero = []

# Local development: Use local filesystem path for blvm-spec-lock
# Only enable this when developing locally (not in CI)
# Usage: cargo build --features local-spec-lock
# Note: When enabled, [patch.crates-io] section overrides the crate dependency
local-spec-lock = []

# Production performance optimizations
# This feature enables runtime optimizations like caching and context reuse
production = ["lru", "rayon", "smallvec", "rustc-hash"]

# Enable rayon for parallelization (optional, can be enabled independently)
rayon = ["dep:rayon"]

# Benchmarking utilities
# Enables cache clearing and state reset functions for reproducible benchmarks
benchmarking = []

# UTXO commitments module
# Enables UTXO set commitments and peer consensus sync
utxo-commitments = ["sparse-merkle-tree"]

# Note: spec-lock feature removed - constants and #[spec_locked] attributes are always available
# Property tests can use constants directly without any feature flag
# The #[spec_locked] attributes are just metadata for formal verification tools

# blvm-spec-macros feature (for spec_locked attributes)  
# Enables spec_locked attribute macro from blvm-spec-macros
# Commented out until blvm-spec-macros is committed
# blvm-spec-macros = ["dep:blvm-spec-macros"]

# Runtime invariant checks in production builds
# Enables runtime verification of mathematical invariants (supply, UTXO consistency, etc.)
# Can be enabled in production for additional safety at performance cost
runtime-invariants = []

# CTV (BIP119 CheckTemplateVerify) - proposed soft fork
# Enables OP_CHECKTEMPLATEVERIFY opcode support
ctv = []

# CSFS (BIP348 CHECKSIGFROMSTACK) - proposed soft fork
# Enables OP_CHECKSIGFROMSTACK opcode support (Tapscript only)
csfs = []


[dependencies.lru]
version = "0.12"
optional = true

[dependencies.rayon]
version = "1.8"
optional = true

[dependencies.sparse-merkle-tree]
version = "0.6"
optional = true

# Target-specific dependency configuration
# sha2-asm doesn't support Windows targets, so disable asm feature for Windows
# Define sha2 per-target to avoid sha2-asm on Windows
[target.'cfg(not(target_os = "windows"))'.dependencies]
sha2 = { version = "=0.10.9", features = ["asm"] }

[target.'cfg(target_os = "windows")'.dependencies]
sha2 = { version = "=0.10.9" }

# Also explicitly handle the GNU Windows target (for cross-compilation)
[target.x86_64-pc-windows-gnu.dependencies]
sha2 = { version = "=0.10.9" }

# Local development: Override blvm-spec-lock to use local path
# This section is only used when developing locally
# In CI, this section is ignored and the default crate/git dependency is used
# To use locally: Create .cargo/config.toml with:
# [patch.crates-io]
# blvm-spec-lock = { path = "../blvm-spec-lock" }
# Or uncomment the section below (not recommended for committed code)

[profile.release]
# Aggressive optimizations for production builds
# Reference: Orange Paper Section 13.1 - Performance Considerations
opt-level = 3
lto = "fat"  # Fat LTO for maximum optimization (slower build, better runtime)
codegen-units = 1  # Single codegen unit maximizes LTO benefits
strip = true  # Remove symbols for smaller binaries
panic = "abort"  # Smaller binaries, no unwinding overhead

# Additional optimizations - ensure all dependencies are optimized
[profile.release.package."*"]
opt-level = 3

# Profile-guided optimization (PGO) setup:
# 
# Automated PGO build script: ./scripts/pgo-build.sh
# 
# Manual PGO steps:
# 1. Build with instrumentation: RUSTFLAGS="-C profile-generate=/tmp/pgo-data" cargo build --release
# 2. Run benchmarks/tests to generate profile data: cargo bench --release
# 3. Build optimized: RUSTFLAGS="-C profile-use=/tmp/pgo-data" cargo build --release
# 
# Note: PGO works with stable Rust 1.70+ (LLVM 15+)
# Expected performance gain: 1.10-1.15x improvement

# Benchmark profile (faster iteration during development)
[profile.bench]
opt-level = 3
debug = false
strip = false
lto = "thin"  # Faster than "fat" for iterative benchmarking
codegen-units = 16  # Faster compilation

# Benchmarks have been moved to blvm-bench crate
# See: https://github.com/BTCDecoded/blvm-bench

[patch.crates-io]
blvm-spec-lock = { path = "../blvm-spec-lock" }
