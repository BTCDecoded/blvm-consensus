[package]
name = "bllvm-consensus"
version = "0.1.4"
edition = "2021"
authors = ["Bitcoin Commons Team"]
description = "Bitcoin Commons BLLVM: Direct mathematical implementation of Bitcoin consensus rules from the Orange Paper"
license = "MIT"
repository = "https://github.com/BTCDecoded/bllvm-consensus"
homepage = "https://btcdecoded.org"
documentation = "https://docs.rs/bllvm-consensus"
keywords = ["bitcoin", "consensus", "blockchain", "cryptocurrency", "proof"]
categories = ["cryptography::cryptocurrencies", "algorithms"]
rust-version = "1.83"

[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = ['cfg(kani)'] }

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

[dependencies]
smallvec = { version = "1.11", optional = true, features = ["serde"] }

# Consensus-critical cryptography - EXACT VERSIONS
secp256k1 = "=0.28.2"
# Pure Rust secp256k1 implementation (Phase 3.2 - migration in progress)
k256 = { version = "=0.13", optional = true, features = ["ecdsa", "sha256"] }
# Enable SIMD optimizations for hashing
# The "asm" feature enables optimized assembly implementations
# Note: sha2-asm doesn't support Windows, so we use target-specific dependencies below
# sha2 is defined in target-specific sections only
ripemd = "=0.1.3"
bitcoin_hashes = "=0.11.0"

# Non-consensus-critical utilities - EXACT VERSIONS for supply chain security
serde = { version = "=1.0.228", features = ["derive"] }  # Updated for iroh 0.95 compatibility
serde_json = "=1.0.108"
anyhow = "=1.0.93"
thiserror = "=1.0.69"
# Binary serialization (for transaction/block encoding in differential tests)
bincode = "=1.3.3"
# Hex encoding (for RPC communication)
hex = "=0.4.3"


[dev-dependencies]
# Formal verification tools - EXACT VERSIONS for reproducibility
proptest = "=1.5.0"
# Fuzzing framework for better test coverage ergonomics
bolero = "0.11"
# HTTP client for differential fuzzing vs Bitcoin Core (Phase 2.2)
reqwest = { version = "0.11", features = ["json"], default-features = false }
# Async runtime for differential fuzzing tests
tokio = { version = "1.35", features = ["rt", "macros"] }
# Performance benchmarking framework
criterion = "0.5"

[dependencies.kani-verifier]
version = "0.66"
optional = true

[features]
default = []
# Enable formal verification tools
verify = ["kani-verifier"]
# Enable k256 (uses deprecated generic_array from elliptic_curve, will be fixed when k256 updates)
k256 = ["dep:k256"]

# Enable fuzzing tests (Bolero framework)
# Note: bolero is a dev-dependency, this feature is just for conditional compilation
# Users should use: cargo test --features bolero
bolero = []

# Production performance optimizations
# This feature enables runtime optimizations like caching and context reuse
# Keep separate from 'verify' to maintain Kani compatibility
production = ["lru", "dep:rayon", "smallvec"]

# Enable rayon for parallelization (optional, can be enabled independently)
rayon = ["dep:rayon"]

# Benchmarking utilities
# Enables cache clearing and state reset functions for reproducible benchmarks
benchmarking = []

# UTXO commitments module
# Enables UTXO set commitments and peer consensus sync
utxo-commitments = ["sparse-merkle-tree"]

# Runtime invariant checks in production builds
# Enables runtime verification of mathematical invariants (supply, UTXO consistency, etc.)
# Can be enabled in production for additional safety at performance cost
runtime-invariants = []

# CTV (BIP119 CheckTemplateVerify) - proposed soft fork
# Enables OP_CHECKTEMPLATEVERIFY opcode support
ctv = []

# Note: Kani proofs use #[cfg(kani)] which is set by the Kani toolchain, not cargo features
# To run Kani proofs, use: cargo kani --features utxo-commitments

[dependencies.lru]
version = "0.12"
optional = true

[dependencies.rayon]
version = "1.8"
optional = true

[dependencies.sparse-merkle-tree]
version = "0.6"
optional = true

# Target-specific dependency configuration
# sha2-asm doesn't support Windows targets, so disable asm feature for Windows
# Define sha2 per-target to avoid sha2-asm on Windows
[target.'cfg(not(target_os = "windows"))'.dependencies]
sha2 = { version = "=0.10.9", features = ["asm"] }

[target.'cfg(target_os = "windows")'.dependencies]
sha2 = { version = "=0.10.9" }

# Also explicitly handle the GNU Windows target (for cross-compilation)
[target.x86_64-pc-windows-gnu.dependencies]
sha2 = { version = "=0.10.9" }

[profile.release]
# Aggressive optimizations for production builds
# Reference: Orange Paper Section 13.1 - Performance Considerations
opt-level = 3
lto = "fat"  # Fat LTO for maximum optimization (slower build, better runtime)
codegen-units = 1  # Single codegen unit maximizes LTO benefits
strip = true  # Remove symbols for smaller binaries
panic = "abort"  # Smaller binaries, no unwinding overhead

# Additional optimizations - ensure all dependencies are optimized
[profile.release.package."*"]
opt-level = 3

# Profile-guided optimization (PGO) setup instructions:
# 1. Build with instrumentation: RUSTFLAGS="-C profile-generate=/tmp/pgo-data" cargo build --release
# 2. Run benchmarks/tests to generate profile data
# 3. Build optimized: RUSTFLAGS="-C profile-use=/tmp/pgo-data" cargo build --release
# Note: PGO requires nightly Rust or specific LLVM versions

# Benchmark profile (faster iteration during development)
[profile.bench]
opt-level = 3
debug = false
strip = false
lto = "thin"  # Faster than "fat" for iterative benchmarking
codegen-units = 16  # Faster compilation

# Benchmarks have been moved to bllvm-bench crate
# See: https://github.com/BTCDecoded/bllvm-bench
