name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [published]
  repository_dispatch:
    types: [build-chain, upstream-changed]
  workflow_dispatch:

permissions:
  contents: read
  actions: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: '1'
  CARGO_INCREMENTAL: '1'

jobs:
  setup:
    name: Setup
    runs-on: [self-hosted, linux, x64]
    outputs:
      cache-key: ${{ steps.setup-cache.outputs.cache-key }}
    steps:
      - name: Disk check
        run: |
          if [ $(df / | tail -1 | awk '{print $5}' | sed 's/%//') -gt 80 ]; then
            find /tmp/runner-cache -maxdepth 2 -type d -mtime +7 -exec rm -rf {} + 2>/dev/null || true
          fi

      - uses: actions/checkout@v4
      
      - name: Cache
        id: setup-cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          
          # Generate cache key from Cargo.lock hash
          DEPS_KEY=$(sha256sum Cargo.lock | cut -d' ' -f1)
          
          # Include toolchain version in cache key
          TOOLCHAIN=$(grep -E '^channel|rust-version' rust-toolchain.toml Cargo.toml 2>/dev/null | head -1 | sha256sum | cut -d' ' -f1 || echo "1.88.0")
          
          CACHE_KEY="${DEPS_KEY}-${TOOLCHAIN}"
          
          # Set up cache directories
          CARGO_CACHE_DIR="$CACHE_ROOT/cargo/$CACHE_KEY"
          TARGET_CACHE_DIR="$CACHE_ROOT/target/$CACHE_KEY"
          
          echo "CARGO_CACHE_DIR=$CARGO_CACHE_DIR" >> $GITHUB_ENV
          echo "TARGET_CACHE_DIR=$TARGET_CACHE_DIR" >> $GITHUB_ENV
          
          echo "cache-key=$CACHE_KEY" >> $GITHUB_OUTPUT
          
          mkdir -p "$CARGO_CACHE_DIR"/{registry,git} "$TARGET_CACHE_DIR"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0

  test:
    name: Test
    needs: setup
    runs-on: [self-hosted, linux, x64]
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
          echo "TARGET_CACHE_DIR=$CACHE_ROOT/target/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          fi
      
      - name: Restore target
        run: |
          if [ -d "$TARGET_CACHE_DIR" ] && [ "$(ls -A $TARGET_CACHE_DIR 2>/dev/null)" ]; then
            rsync -a --delete "$TARGET_CACHE_DIR/" ./target/ || true
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Run tests
        run: |
          # Run tests in parallel (default) with minimal output for speed
          # Use --lib --bins --tests to ensure all test types run
          cargo test --lib --bins --tests
      
      - name: Coverage
        run: |
          cargo install cargo-tarpaulin --version 0.27.0
          # Use --skip-clean to avoid rebuilding, --timeout to prevent hangs
          cargo tarpaulin --out xml --output-dir coverage --timeout 120 --skip-clean
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: coverage/cobertura.xml
      
      - name: Cache registry
        if: always()
        run: |
          if [ -d "$HOME/.cargo/registry" ] && [ "$CARGO_CACHE_DIR" != "" ]; then
            rsync -a --delete "$HOME/.cargo/registry/" "$CARGO_CACHE_DIR/registry/" || true
          fi
      
      - name: Cache git
        if: always()
        run: |
          if [ -d "$HOME/.cargo/git" ] && [ "$CARGO_CACHE_DIR" != "" ]; then
            rsync -a --delete "$HOME/.cargo/git/" "$CARGO_CACHE_DIR/git/" || true
          fi
      
      - name: Cache target
        if: always()
        run: |
          if [ -d "./target" ] && [ "$TARGET_CACHE_DIR" != "" ]; then
            rsync -a --delete ./target/ "$TARGET_CACHE_DIR/" || true
          fi

  clippy:
    name: Clippy
    needs: setup
    runs-on: [self-hosted, linux, x64]
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
          components: clippy
      
      - name: Run clippy
        run: cargo clippy -- -D warnings

  fmt:
    name: Format
    needs: setup
    runs-on: [self-hosted, linux, x64]
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
          components: rustfmt
      
      - name: Format
        run: cargo fmt -- --check

  docs:
    name: Docs
    needs: setup
    runs-on: [self-hosted, linux, x64]
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Docs
        run: cargo doc --no-deps
      
      - name: Verify docs
        run: cargo doc --no-deps --document-private-items

  security:
    name: Security
    needs: setup
    runs-on: [self-hosted, linux, x64]
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Install audit
        run: cargo install cargo-audit --version 0.21.0 --locked
      
      - name: Audit
        run: cargo audit

  verify:
    name: Verify
    needs: setup
    runs-on: [self-hosted, Linux, X64, perf]
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Verify Kani is available
        run: |
          echo "Checking for Kani model checker..."
          # Check if kani is available (should be pre-installed on runner)
          if command -v kani &> /dev/null; then
            echo "‚úÖ Found kani command: $(which kani)"
            kani --version || echo "Version check failed, but kani exists"
          elif command -v cargo &> /dev/null && cargo kani --version &> /dev/null; then
            echo "‚úÖ Found cargo kani subcommand"
            cargo kani --version
          else
            echo "‚ùå Kani not found on runner"
            echo "PATH: $PATH"
            echo "Please ensure Kani is installed on the runner"
            echo "Install with: curl -fsSL https://model-checking.github.io/kani/install.sh | sh -s -- -y"
            exit 1
          fi
      
      - name: Determine proof tier
        id: proof_tier
        run: |
          # Determine which proofs to run based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # PRs: Fast + Medium proofs (174 total)
            echo "tier=fast_medium" >> $GITHUB_OUTPUT
            echo "description=Fast + Medium proofs (174 proofs)" >> $GITHUB_OUTPUT
            echo "unwind_max=9" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ] || [ "${{ github.ref }}" = "refs/heads/master" ]; then
            # Push to main: All proofs (195 total)
            echo "tier=all" >> $GITHUB_OUTPUT
            echo "description=All proofs (195 proofs)" >> $GITHUB_OUTPUT
            echo "unwind_max=999" >> $GITHUB_OUTPUT
          else
            # Other pushes: Fast proofs only (103 total)
            echo "tier=fast" >> $GITHUB_OUTPUT
            echo "description=Fast proofs only (103 proofs)" >> $GITHUB_OUTPUT
            echo "unwind_max=3" >> $GITHUB_OUTPUT
          fi
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Tier: ${{ steps.proof_tier.outputs.tier }}"
          echo "Description: ${{ steps.proof_tier.outputs.description }}"
      
      - name: Run Kani proofs (Fast - every push)
        if: steps.proof_tier.outputs.tier == 'fast'
        run: |
          echo "‚ö° Running Kani proofs - Fast tier (103 proofs, unwind <= 3)..."
          echo "Note: Running with minimal parallelism (2 jobs) to avoid OOM"
          # Get list of fast proofs
          FAST_PROOFS=$(python3 scripts/get_proofs_by_tier.py fast)
          PROOF_COUNT=$(echo "$FAST_PROOFS" | wc -w)
          echo "Found $PROOF_COUNT fast proofs to run"
          TEMP_OUTPUT=$(mktemp)
          trap "rm -f $TEMP_OUTPUT" EXIT
          set +e
          # Build harness filter arguments
          HARNESS_ARGS=""
          for proof in $FAST_PROOFS; do
            HARNESS_ARGS="$HARNESS_ARGS --harness $proof"
          done
          cargo kani --features verify --output-format terse --solver cadical --jobs 2 $HARNESS_ARGS 2>&1 | grep -v "aborting path on assume(false)" | tee "$TEMP_OUTPUT"
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          if [ $EXIT_CODE -ne 0 ]; then
            echo "‚ùå Fast Kani proofs failed (exit code: $EXIT_CODE)"
            exit $EXIT_CODE
          fi
          echo "‚úÖ Fast proofs verified successfully"
      
      - name: Run Kani proofs (Fast + Medium - PRs)
        if: steps.proof_tier.outputs.tier == 'fast_medium'
        run: |
          echo "üîç Running Kani proofs - Fast + Medium tier (174 proofs, unwind <= 9)..."
          echo "Note: Running with minimal parallelism (2 jobs) to avoid OOM"
          # Get list of fast + medium proofs
          FAST_MEDIUM_PROOFS=$(python3 scripts/get_proofs_by_tier.py fast_medium)
          PROOF_COUNT=$(echo "$FAST_MEDIUM_PROOFS" | wc -w)
          echo "Found $PROOF_COUNT fast + medium proofs to run"
          TEMP_OUTPUT=$(mktemp)
          trap "rm -f $TEMP_OUTPUT" EXIT
          set +e
          # Build harness filter arguments
          HARNESS_ARGS=""
          for proof in $FAST_MEDIUM_PROOFS; do
            HARNESS_ARGS="$HARNESS_ARGS --harness $proof"
          done
          cargo kani --features verify --output-format terse --solver cadical --jobs 2 $HARNESS_ARGS 2>&1 | grep -v "aborting path on assume(false)" | tee "$TEMP_OUTPUT"
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          if [ $EXIT_CODE -ne 0 ]; then
            echo "‚ùå Fast + Medium Kani proofs failed (exit code: $EXIT_CODE)"
            exit $EXIT_CODE
          fi
          echo "‚úÖ Fast + Medium proofs verified successfully"
      
      - name: Run Kani proofs (All - main branch)
        if: steps.proof_tier.outputs.tier == 'all'
        run: |
          echo "üêå Running Kani proofs - All tier (195 proofs, all unwind bounds)..."
          echo "Note: Running with minimal parallelism (2 jobs) to avoid OOM"
          echo "This includes slow proofs (unwind >= 10) which take significantly longer"
          TEMP_OUTPUT=$(mktemp)
          trap "rm -f $TEMP_OUTPUT" EXIT
          set +e
          # Run all proofs (no filter)
          cargo kani --features verify --output-format terse --solver cadical --jobs 2 2>&1 | grep -v "aborting path on assume(false)" | tee "$TEMP_OUTPUT"
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          if [ $EXIT_CODE -ne 0 ]; then
            echo "‚ùå All Kani proofs failed (exit code: $EXIT_CODE)"
            echo "This is critical for consensus correctness - review proofs before release"
            exit $EXIT_CODE
          fi
          echo "‚úÖ All Kani proofs verified successfully"
      
      - name: Run property tests with all features
        run: |
          echo "üß™ Running property-based tests with all features (35+ tests)..."
          # Property tests can run in parallel (they're designed to be independent)
          cargo test --all-features --test consensus_property_tests || {
            echo "‚ùå Property tests failed"
            echo "Mathematical invariants must hold - review failures before release"
            exit 1
          }
          echo "‚úÖ All property tests passed"
      
      - name: MIRI undefined behavior checks
        continue-on-error: true
        run: |
          echo "üîç Running MIRI checks for undefined behavior..."
          rustup toolchain install nightly --component miri || {
            echo "‚ö†Ô∏è  Could not install MIRI, skipping (non-blocking)"
            exit 0
          }
          cargo +nightly miri setup || {
            echo "‚ö†Ô∏è  MIRI setup failed, skipping (non-blocking)"
            exit 0
          }
          # Run a subset of critical tests under MIRI (full suite can be slow)
          echo "Running critical property tests under MIRI..."
          cargo +nightly miri test --all-features --test consensus_property_tests --lib -- --test-threads=1 || {
            echo "‚ö†Ô∏è  MIRI checks found potential undefined behavior (non-blocking)"
            echo "Review MIRI output for details"
            exit 0
          }
          echo "‚úÖ MIRI checks passed"

  build:
    name: Build
    needs: [setup, test, clippy, fmt, docs, security, verify]
    runs-on: [self-hosted, linux, x64]
    if: github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'repository_dispatch'
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
          echo "TARGET_CACHE_DIR=$CACHE_ROOT/target/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          fi
      
      - name: Restore target
        run: |
          if [ -d "$TARGET_CACHE_DIR" ] && [ "$(ls -A $TARGET_CACHE_DIR 2>/dev/null)" ]; then
            rsync -a --delete "$TARGET_CACHE_DIR/" ./target/ || true
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Build
        run: cargo build --release
      
      - name: Cache target
        if: always()
        run: |
          if [ -d "./target" ] && [ "$TARGET_CACHE_DIR" != "" ]; then
            mkdir -p "$TARGET_CACHE_DIR" || true
            rsync -a --delete ./target/ "$TARGET_CACHE_DIR/" || true
          fi
      
      - name: Cleanup
        if: always()
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          find "$CACHE_ROOT/cargo" -maxdepth 1 -type d -mtime +1 2>/dev/null | head -n -5 | xargs rm -rf 2>/dev/null || true
          find "$CACHE_ROOT/target" -maxdepth 1 -type d -mtime +1 2>/dev/null | head -n -3 | xargs rm -rf 2>/dev/null || true

  release:
    name: Release
    needs: build
    runs-on: [self-hosted, linux, x64]
    if: |
      github.event_name == 'push' &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') &&
      !contains(github.event.head_commit.message, '[skip release]')
    permissions:
      contents: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Check for breaking changes
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          echo "üîç Checking for breaking changes in commit messages..."
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          else
            COMMIT_RANGE="HEAD~20..HEAD"
          fi
          
          # Check for breaking change indicators
          if git log "$COMMIT_RANGE" --pretty=format:"%s" | grep -qiE "(breaking|!|major|incompatible)"; then
            echo "‚ö†Ô∏è  WARNING: Potential breaking changes detected in commit messages"
            echo "   Consider bumping major or minor version instead of patch"
            git log "$COMMIT_RANGE" --pretty=format:"  - %s" | grep -iE "(breaking|!|major|incompatible)" || true
          else
            echo "‚úÖ No obvious breaking changes detected"
          fi
      
      - name: Check CHANGELOG
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          echo "üìù Checking CHANGELOG.md..."
          if [ ! -f "CHANGELOG.md" ]; then
            echo "‚ö†Ô∏è  CHANGELOG.md not found (optional but recommended)"
            exit 0
          fi
          
          # Check if there's an [Unreleased] section with content
          if grep -q "^## \[Unreleased\]" CHANGELOG.md; then
            UNRELEASED_LINES=$(sed -n '/^## \[Unreleased\]/,/^## /p' CHANGELOG.md | grep -c "^-" || echo "0")
            if [ "$UNRELEASED_LINES" -gt 0 ]; then
              echo "‚úÖ CHANGELOG.md has [Unreleased] entries ($UNRELEASED_LINES items)"
            else
              echo "‚ö†Ô∏è  CHANGELOG.md has [Unreleased] section but no entries"
            fi
          else
            echo "‚ö†Ô∏è  CHANGELOG.md doesn't have [Unreleased] section"
          fi
      
      - name: Determine version
        id: version
        run: |
          # Auto-increment patch version from Cargo.toml
          # Extract only the package version (first version = after [package])
          CURRENT=$(grep -A 10 '^\[package\]' Cargo.toml | grep '^version = ' | head -1 | sed -E 's/^version = "([^"]+)".*/\1/')
          if [ -z "$CURRENT" ]; then
            echo "‚ùå Could not determine current version from Cargo.toml"
            echo "Debug: Looking for version in [package] section"
            grep -A 10 '^\[package\]' Cargo.toml | head -10
            exit 1
          fi
          
          echo "Current version: ${CURRENT}"
          
          # Validate version format (should be X.Y.Z)
          if ! echo "$CURRENT" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "‚ùå Invalid version format: ${CURRENT} (expected X.Y.Z)"
            exit 1
          fi
          
          # Increment patch version (X.Y.Z -> X.Y.(Z+1))
          MAJOR=$(echo "$CURRENT" | cut -d. -f1)
          MINOR=$(echo "$CURRENT" | cut -d. -f2)
          PATCH=$(echo "$CURRENT" | cut -d. -f3)
          
          # Validate components are numeric
          if ! [[ "$MAJOR" =~ ^[0-9]+$ ]] || ! [[ "$MINOR" =~ ^[0-9]+$ ]] || ! [[ "$PATCH" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Version components must be numeric: ${MAJOR}.${MINOR}.${PATCH}"
            exit 1
          fi
          
          PATCH=$((PATCH + 1))
          VERSION="${MAJOR}.${MINOR}.${PATCH}"
          VERSION_TAG="v${VERSION}"
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
          echo "‚úÖ Releasing version: ${VERSION_TAG}"
      
      - name: Update Cargo.lock first (before version change)
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          # Remove old lock file and regenerate to ensure latest dependency versions
          rm -f Cargo.lock
          cargo update
          echo "‚úÖ Cargo.lock regenerated with latest dependencies"
          # Verify kani-verifier version
          if grep -q "kani-verifier" Cargo.lock 2>/dev/null; then
            echo "kani-verifier version in Cargo.lock:"
            grep -A 2 "name = \"kani-verifier\"" Cargo.lock | head -3
          fi
      
      - name: Update version in Cargo.toml
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "Updating package version to ${VERSION}"
          
          # Use awk to update only the version in [package] section
          export VERSION
          awk -v ver="$VERSION" '
            /^\[package\]/ { in_package = 1; print; next }
            /^\[/ { in_package = 0 }
            in_package && /^version = / { 
              print "version = \"" ver "\""
              next
            }
            { print }
          ' Cargo.toml > Cargo.toml.tmp && mv Cargo.toml.tmp Cargo.toml
          
          echo "‚úÖ Updated Cargo.toml to version ${VERSION}"
          echo "Package version line:"
          grep "^version = " Cargo.toml | head -1
          echo "Verifying kani-verifier is unchanged:"
          grep -A 1 "\[dependencies.kani-verifier\]" Cargo.toml
      
      - name: Regenerate Cargo.lock after version change
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          # Regenerate lock file after version change to ensure consistency
          rm -f Cargo.lock
          cargo update
          echo "‚úÖ Cargo.lock regenerated after version update"
          
          # Verify the package version in Cargo.lock matches
          if grep -q "name = \"bllvm-consensus\"" Cargo.lock 2>/dev/null; then
            echo "Package version in Cargo.lock:"
            grep -A 1 "name = \"bllvm-consensus\"" Cargo.lock | grep "version" | head -1
          fi
      
      - name: Pre-release smoke test
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          echo "üß™ Running smoke tests with new version..."
          # Quick compile check
          cargo check --quiet || {
            echo "‚ùå Compilation failed after version update"
            exit 1
          }
          # Run a quick test to ensure nothing broke
          cargo test --lib --quiet -- --test-threads=1 || {
            echo "‚ùå Tests failed after version update"
            exit 1
          }
          echo "‚úÖ Smoke tests passed"
      
      - name: Commit Cargo.toml and Cargo.lock changes
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Cargo.toml Cargo.lock
          git commit -m "Bump version to ${{ steps.version.outputs.version }} for release" || true
      
      - name: Check for crates.io token
        run: |
          if [ -z "${CARGO_REGISTRY_TOKEN:-}" ]; then
            echo "‚ö†Ô∏è  CARGO_REGISTRY_TOKEN not set, skipping crate publication"
            echo "   Set CARGO_REGISTRY_TOKEN secret to enable crate publishing"
            exit 0
          fi
      
      - name: Configure cargo for crates.io
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          cargo login "${CARGO_REGISTRY_TOKEN}"
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
      
      - name: Verify package version before packaging
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          EXPECTED_VERSION="${{ steps.version.outputs.version }}"
          ACTUAL_VERSION=$(grep -A 10 '^\[package\]' Cargo.toml | grep '^version = ' | head -1 | sed -E 's/^version = "([^"]+)".*/\1/')
          echo "Expected version: ${EXPECTED_VERSION}"
          echo "Actual version in Cargo.toml: ${ACTUAL_VERSION}"
          if [ "$ACTUAL_VERSION" != "$EXPECTED_VERSION" ]; then
            echo "‚ùå Version mismatch! Expected ${EXPECTED_VERSION} but found ${ACTUAL_VERSION}"
            exit 1
          fi
          echo "‚úÖ Version matches: ${ACTUAL_VERSION}"
      
      - name: Verify package
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          cargo package --list
      
      - name: Dry-run publish
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          cargo publish --dry-run
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
      
      - name: Check if version already exists
        if: env.CARGO_REGISTRY_TOKEN != ''
        id: check-version
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          CRATE_NAME=$(grep -E '^name = ' Cargo.toml | sed -E 's/^name = "([^"]+)".*/\1/')
          if cargo search "$CRATE_NAME" --limit 1 2>/dev/null | grep -q "v${VERSION}"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Version ${VERSION} already published for ${CRATE_NAME}"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Version ${VERSION} not yet published for ${CRATE_NAME}"
          fi
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
      
      - name: Publish to crates.io
        if: |
          env.CARGO_REGISTRY_TOKEN != '' &&
          steps.check-version.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          CRATE_NAME=$(grep -E '^name = ' Cargo.toml | sed -E 's/^name = "([^"]+)".*/\1/')
          echo "Publishing ${CRATE_NAME} v${VERSION} to crates.io..."
          cargo publish --token "${CARGO_REGISTRY_TOKEN}"
          echo "‚úÖ Successfully published ${CRATE_NAME} v${VERSION}"
          echo "Waiting 30 seconds for crates.io to index..."
          sleep 30
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

      - name: Create git tag
        run: |
          VERSION_TAG="${{ steps.version.outputs.version_tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if tag already exists
          if git rev-parse "$VERSION_TAG" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Tag ${VERSION_TAG} already exists, skipping tag creation"
          else
            git tag -a "$VERSION_TAG" -m "Release ${VERSION_TAG}"
            git push origin "$VERSION_TAG"
            echo "‚úÖ Created and pushed tag ${VERSION_TAG}"
          fi
      
      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          VERSION_TAG="${{ steps.version.outputs.version_tag }}"
          CRATE_NAME=$(grep -E '^name = ' Cargo.toml | sed -E 's/^name = "([^"]+)".*/\1/')
          DESCRIPTION=$(grep -E '^description = ' Cargo.toml | sed -E 's/^description = "([^"]+)".*/\1/' || echo "Bitcoin consensus implementation")
          
          # Get commit range for this release
          if [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
            COMMIT_RANGE="${{ github.event.before }}..${{ github.sha }}"
            COMMIT_COUNT=$(git rev-list --count "$COMMIT_RANGE" 2>/dev/null || echo "?")
          else
            COMMIT_RANGE="HEAD~10..HEAD"
            COMMIT_COUNT="?"
          fi
          
          cat > /tmp/release_notes.md << EOF
          ## $VERSION_TAG
          
          **$DESCRIPTION**
          
          ### üì¶ Installation
          
          Add to your \`Cargo.toml\`:
          
          \`\`\`toml
          [dependencies]
          $CRATE_NAME = "$VERSION"
          \`\`\`
          
          Or install via cargo:
          
          \`\`\`bash
          cargo add $CRATE_NAME@$VERSION
          \`\`\`
          
          ### üîó Links
          
          - **Crates.io**: [${CRATE_NAME} v${VERSION}](https://crates.io/crates/${CRATE_NAME}/${VERSION})
          - **Documentation**: [docs.rs/${CRATE_NAME}/${VERSION}](https://docs.rs/${CRATE_NAME}/${VERSION})
          - **Repository**: [GitHub](https://github.com/${{ github.repository }})
          
          ### üìù Changes
          
          This release includes $COMMIT_COUNT commits since the last release.
          
          **Published to crates.io**: ${{ steps.check-version.outputs.exists == 'false' && '‚úÖ Yes' || '‚ö†Ô∏è  Already exists or skipped' }}
          
          See [full commit history](https://github.com/${{ github.repository }}/compare/$COMMIT_RANGE) for details.
          EOF
          
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          cat /tmp/release_notes.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version_tag }}
          name: Release ${{ steps.version.outputs.version_tag }}
          body: ${{ steps.release_notes.outputs.notes }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
