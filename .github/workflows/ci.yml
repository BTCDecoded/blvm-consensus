name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [published]
  repository_dispatch:
    types: [build-chain, upstream-changed]
  workflow_dispatch:
    inputs:
      skip_verification:
        description: 'Skip Kani verification and attestation steps'
        required: false
        type: boolean
        default: false
      skip_tests:
        description: 'Skip test execution and coverage steps'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  actions: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: '1'
  CARGO_INCREMENTAL: '1'

jobs:
  setup:
    name: Setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]')))
    outputs:
      cache-key: ${{ steps.setup-cache.outputs.cache-key }}
    steps:
      - name: Disk check
        run: |
          if [ $(df / | tail -1 | awk '{print $5}' | sed 's/%//') -gt 80 ]; then
            find /tmp/runner-cache -maxdepth 2 -type d -mtime +7 -exec rm -rf {} + 2>/dev/null || true
          fi

      - uses: actions/checkout@v4
      
      - name: Cache
        id: setup-cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          
          # Generate cache key from Cargo.lock hash
          DEPS_KEY=$(sha256sum Cargo.lock | cut -d' ' -f1)
          
          # Include toolchain version in cache key
          TOOLCHAIN=$(grep -E '^channel|rust-version' rust-toolchain.toml Cargo.toml 2>/dev/null | head -1 | sha256sum | cut -d' ' -f1 || echo "1.88.0")
          
          CACHE_KEY="${DEPS_KEY}-${TOOLCHAIN}"
          
          # Set up cache directories
          CARGO_CACHE_DIR="$CACHE_ROOT/cargo/$CACHE_KEY"
          TARGET_CACHE_DIR="$CACHE_ROOT/target/$CACHE_KEY"
          
          echo "CARGO_CACHE_DIR=$CARGO_CACHE_DIR" >> $GITHUB_ENV
          echo "TARGET_CACHE_DIR=$TARGET_CACHE_DIR" >> $GITHUB_ENV
          
          echo "cache-key=$CACHE_KEY" >> $GITHUB_OUTPUT
          
          mkdir -p "$CARGO_CACHE_DIR"/{registry,git} "$TARGET_CACHE_DIR"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0

  test:
    name: Test
    needs: setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]'))) &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.skip_tests != 'true')
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
          echo "TARGET_CACHE_DIR=$CACHE_ROOT/target/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          fi
      
      - name: Restore target
        run: |
          if [ -d "$TARGET_CACHE_DIR" ] && [ "$(ls -A $TARGET_CACHE_DIR 2>/dev/null)" ]; then
            rsync -a --delete "$TARGET_CACHE_DIR/" ./target/ || true
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Run tests
        run: |
          # Run tests in parallel (default) with minimal output for speed
          # Use --lib --bins --tests to ensure all test types run
          cargo test --lib --bins --tests
      
      - name: Coverage
        id: coverage
        run: |
          cargo install cargo-tarpaulin --version 0.27.0
          # Use --skip-clean to avoid rebuilding, --timeout to prevent hangs
          cargo tarpaulin --out xml --output-dir coverage --timeout 120 --skip-clean
          # Extract coverage percentage from XML
          if [ -f "coverage/cobertura.xml" ]; then
            COVERAGE_PCT=$(grep -oP 'line-rate="\K[0-9.]+' coverage/cobertura.xml | head -1 | awk '{printf "%.2f", $1 * 100}')
            echo "coverage_percent=$COVERAGE_PCT" >> $GITHUB_OUTPUT
            echo "Coverage: ${COVERAGE_PCT}%"
          else
            echo "coverage_percent=0.00" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Coverage file not found"
          fi
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: coverage/cobertura.xml
      
      - name: Capture test output hash
        if: github.ref == 'refs/heads/main'
        run: |
          # Capture test output and hash it
          TEST_OUTPUT_FILE="test_output.txt"
          # Re-run tests with output capture (or use existing test output if available)
          cargo test --lib --bins --tests -- --nocapture 2>&1 | tee "$TEST_OUTPUT_FILE" || true
          UNIT_TESTS_HASH=$(sha256sum "$TEST_OUTPUT_FILE" | cut -d' ' -f1)
          echo "unit_tests_hash=$UNIT_TESTS_HASH" >> $GITHUB_ENV
          echo "Test output hash: $UNIT_TESTS_HASH"
      
      - name: Upload test data for attestation
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: test-attestation-data
          path: |
            test_output.txt
            coverage/cobertura.xml
          retention-days: 90
      
      - name: Cache registry
        if: always()
        run: |
          if [ -d "$HOME/.cargo/registry" ] && [ "$CARGO_CACHE_DIR" != "" ]; then
            rsync -a --delete "$HOME/.cargo/registry/" "$CARGO_CACHE_DIR/registry/" || true
          fi
      
      - name: Cache git
        if: always()
        run: |
          if [ -d "$HOME/.cargo/git" ] && [ "$CARGO_CACHE_DIR" != "" ]; then
            rsync -a --delete "$HOME/.cargo/git/" "$CARGO_CACHE_DIR/git/" || true
          fi
      
      - name: Cache target
        if: always()
        run: |
          if [ -d "./target" ] && [ "$TARGET_CACHE_DIR" != "" ]; then
            rsync -a --delete ./target/ "$TARGET_CACHE_DIR/" || true
          fi

  clippy:
    name: Clippy
    needs: setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]')))
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
          components: clippy
      
      - name: Run clippy
        run: cargo clippy -- -D warnings

  fmt:
    name: Format
    needs: setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]')))
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
          components: rustfmt
      
      - name: Format
        run: cargo fmt -- --check

  docs:
    name: Docs
    needs: setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]')))
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Docs
        run: cargo doc --no-deps
      
      - name: Verify docs
        run: cargo doc --no-deps --document-private-items

  security:
    name: Security
    needs: setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]')))
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Install audit
        run: cargo install cargo-audit --version 0.21.0 --locked
      
      - name: Audit
        run: cargo audit

  verify:
    name: Verify
    needs: setup
    runs-on: [self-hosted, Linux, X64, perf]
      timeout-minutes: 360  # 6 hours for all proofs (195 proofs can take a long time)
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]'))) &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.skip_verification != 'true')
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Verify Kani is available
        run: |
          echo "Checking for Kani model checker..."
          # Check if kani is available (should be pre-installed on runner)
          if command -v kani &> /dev/null; then
            echo "‚úÖ Found kani command: $(which kani)"
            kani --version || echo "Version check failed, but kani exists"
          elif command -v cargo &> /dev/null && cargo kani --version &> /dev/null; then
            echo "‚úÖ Found cargo kani subcommand"
            cargo kani --version
          else
            echo "‚ùå Kani not found on runner"
            echo "PATH: $PATH"
            echo "Please ensure Kani is installed on the runner"
            echo "Install with: curl -fsSL https://model-checking.github.io/kani/install.sh | sh -s -- -y"
            exit 1
          fi
      
      - name: Determine proof tier
        id: proof_tier
        run: |
          # Determine which proofs to run based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # PRs: Fast + Medium proofs (174 total)
            echo "tier=fast_medium" >> $GITHUB_OUTPUT
            echo "description=Fast + Medium proofs (174 proofs)" >> $GITHUB_OUTPUT
            echo "unwind_max=9" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ] || [ "${{ github.ref }}" = "refs/heads/master" ]; then
            # Push to main: All proofs (195 total)
            echo "tier=all" >> $GITHUB_OUTPUT
            echo "description=All proofs (195 proofs)" >> $GITHUB_OUTPUT
            echo "unwind_max=999" >> $GITHUB_OUTPUT
          else
            # Other pushes: Fast proofs only (103 total)
            echo "tier=fast" >> $GITHUB_OUTPUT
            echo "description=Fast proofs only (103 proofs)" >> $GITHUB_OUTPUT
            echo "unwind_max=3" >> $GITHUB_OUTPUT
          fi
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Tier: ${{ steps.proof_tier.outputs.tier }}"
          echo "Description: ${{ steps.proof_tier.outputs.description }}"
      
      - name: Run Kani proofs (Fast - every push)
        if: steps.proof_tier.outputs.tier == 'fast'
        run: |
          echo "‚ö° Running Kani proofs - Fast tier (103 proofs, unwind <= 3)..."
          echo "Note: Running with minimal parallelism (2 jobs) to avoid OOM"
          # Get list of fast proofs
          FAST_PROOFS=$(python3 scripts/get_proofs_by_tier.py fast)
          PROOF_COUNT=$(echo "$FAST_PROOFS" | wc -w)
          echo "Found $PROOF_COUNT fast proofs to run"
          TEMP_OUTPUT=$(mktemp)
          KANI_OUTPUT_FILE="kani_output.txt"
          trap "rm -f $TEMP_OUTPUT" EXIT
          set +e
          # Build harness filter arguments
          HARNESS_ARGS=""
          for proof in $FAST_PROOFS; do
            HARNESS_ARGS="$HARNESS_ARGS --harness $proof"
          done
          cargo kani --features verify --output-format terse --solver cadical --jobs 2 $HARNESS_ARGS 2>&1 | tee "$KANI_OUTPUT_FILE" | grep -v "aborting path on assume(false)" | tee "$TEMP_OUTPUT"
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          if [ $EXIT_CODE -ne 0 ]; then
            if [ $EXIT_CODE -eq 143 ]; then
              echo "‚ö†Ô∏è  Fast Kani proofs were terminated (exit code 143 = SIGTERM)"
              echo "This usually means the job timed out or was killed due to resource limits"
              echo "Consider running proofs in smaller batches or increasing timeout"
              exit $EXIT_CODE
            else
              echo "‚ùå Fast Kani proofs failed (exit code: $EXIT_CODE)"
              exit $EXIT_CODE
            fi
          fi
          echo "‚úÖ Fast proofs verified successfully"
          # Hash the Kani output for attestation (only on main branch)
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            KANI_OUTPUT_HASH=$(sha256sum "$KANI_OUTPUT_FILE" | cut -d' ' -f1)
            echo "kani_output_hash=$KANI_OUTPUT_HASH" >> $GITHUB_ENV
            echo "kani_verified=true" >> $GITHUB_ENV
            echo "kani_proofs=$PROOF_COUNT" >> $GITHUB_ENV
            echo "Kani output hash: $KANI_OUTPUT_HASH"
          fi
      
      - name: Upload Kani output for attestation (Fast)
        if: steps.proof_tier.outputs.tier == 'fast' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: kani-attestation-data
          path: kani_output.txt
          retention-days: 90
      
      - name: Run Kani proofs (Fast + Medium - PRs)
        if: steps.proof_tier.outputs.tier == 'fast_medium'
        run: |
          echo "üîç Running Kani proofs - Fast + Medium tier (174 proofs, unwind <= 9)..."
          echo "Note: Running with minimal parallelism (2 jobs) to avoid OOM"
          # Get list of fast + medium proofs
          FAST_MEDIUM_PROOFS=$(python3 scripts/get_proofs_by_tier.py fast_medium)
          PROOF_COUNT=$(echo "$FAST_MEDIUM_PROOFS" | wc -w)
          echo "Found $PROOF_COUNT fast + medium proofs to run"
          TEMP_OUTPUT=$(mktemp)
          KANI_OUTPUT_FILE="kani_output.txt"
          trap "rm -f $TEMP_OUTPUT" EXIT
          set +e
          # Build harness filter arguments
          HARNESS_ARGS=""
          for proof in $FAST_MEDIUM_PROOFS; do
            HARNESS_ARGS="$HARNESS_ARGS --harness $proof"
          done
          cargo kani --features verify --output-format terse --solver cadical --jobs 2 $HARNESS_ARGS 2>&1 | tee "$KANI_OUTPUT_FILE" | grep -v "aborting path on assume(false)" | tee "$TEMP_OUTPUT"
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          if [ $EXIT_CODE -ne 0 ]; then
            if [ $EXIT_CODE -eq 143 ]; then
              echo "‚ö†Ô∏è  Fast + Medium Kani proofs were terminated (exit code 143 = SIGTERM)"
              echo "This usually means the job timed out or was killed due to resource limits"
              echo "Consider running proofs in smaller batches or increasing timeout"
              exit $EXIT_CODE
            else
              echo "‚ùå Fast + Medium Kani proofs failed (exit code: $EXIT_CODE)"
              exit $EXIT_CODE
            fi
          fi
          echo "‚úÖ Fast + Medium proofs verified successfully"
          # Hash the Kani output for attestation (only on main branch)
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            KANI_OUTPUT_HASH=$(sha256sum "$KANI_OUTPUT_FILE" | cut -d' ' -f1)
            echo "kani_output_hash=$KANI_OUTPUT_HASH" >> $GITHUB_ENV
            echo "kani_verified=true" >> $GITHUB_ENV
            echo "kani_proofs=$PROOF_COUNT" >> $GITHUB_ENV
            echo "Kani output hash: $KANI_OUTPUT_HASH"
          fi
      
      - name: Upload Kani output for attestation (Fast + Medium)
        if: steps.proof_tier.outputs.tier == 'fast_medium' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: kani-attestation-data
          path: kani_output.txt
          retention-days: 90
      
      - name: Run Kani proofs (All - main branch)
        if: steps.proof_tier.outputs.tier == 'all'
        timeout-minutes: 360  # 6 hours - all 195 proofs can take 4-6 hours
        run: |
          echo "üêå Running Kani proofs - All tier (195 proofs, all unwind bounds)..."
          echo "Note: Running with minimal parallelism (2 jobs) to avoid OOM"
          echo "This includes slow proofs (unwind >= 10) which take significantly longer"
          echo "Expected duration: 4-6 hours for all proofs"
          echo "Job timeout: 360 minutes (6 hours)"
          TEMP_OUTPUT=$(mktemp)
          KANI_OUTPUT_FILE="kani_output.txt"
          trap "rm -f $TEMP_OUTPUT" EXIT
          set +e
          # Run all proofs (no filter) and save full output
          # Note: This can take 4-6 hours for all 195 proofs
          cargo kani --features verify --output-format terse --solver cadical --jobs 2 2>&1 | tee "$KANI_OUTPUT_FILE" | grep -v "aborting path on assume(false)" | tee "$TEMP_OUTPUT"
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          if [ $EXIT_CODE -ne 0 ]; then
            if [ $EXIT_CODE -eq 143 ]; then
              echo "‚ö†Ô∏è  All Kani proofs were terminated (exit code 143 = SIGTERM)"
              echo "This usually means the job timed out or was killed due to resource limits"
              echo "The 'all' tier with 195 proofs can take 4-6 hours to complete"
              echo "Consider:"
              echo "  1. Increasing the job timeout (currently 360 minutes)"
              echo "  2. Running proofs in smaller batches"
              echo "  3. Using a runner with more memory/CPU"
              echo "  4. Running only fast+medium proofs for PRs"
              exit $EXIT_CODE
            else
              echo "‚ùå All Kani proofs failed (exit code: $EXIT_CODE)"
              echo "This is critical for consensus correctness - review proofs before release"
              exit $EXIT_CODE
            fi
          fi
          echo "‚úÖ All Kani proofs verified successfully"
          # Hash the Kani output for attestation
          KANI_OUTPUT_HASH=$(sha256sum "$KANI_OUTPUT_FILE" | cut -d' ' -f1)
          echo "kani_output_hash=$KANI_OUTPUT_HASH" >> $GITHUB_ENV
          echo "kani_verified=true" >> $GITHUB_ENV
          echo "kani_proofs=195" >> $GITHUB_ENV
          echo "Kani output hash: $KANI_OUTPUT_HASH"
      
      - name: Upload Kani output for attestation
        if: steps.proof_tier.outputs.tier == 'all' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: kani-attestation-data
          path: kani_output.txt
          retention-days: 90
      
      - name: Run property tests with all features
        run: |
          echo "üß™ Running property-based tests with all features (35+ tests)..."
          # Property tests can run in parallel (they're designed to be independent)
          cargo test --all-features --test consensus_property_tests || {
            echo "‚ùå Property tests failed"
            echo "Mathematical invariants must hold - review failures before release"
            exit 1
          }
          echo "‚úÖ All property tests passed"
      
      - name: MIRI undefined behavior checks
        continue-on-error: true
        run: |
          echo "üîç Running MIRI checks for undefined behavior..."
          rustup toolchain install nightly --component miri || {
            echo "‚ö†Ô∏è  Could not install MIRI, skipping (non-blocking)"
            exit 0
          }
          cargo +nightly miri setup || {
            echo "‚ö†Ô∏è  MIRI setup failed, skipping (non-blocking)"
            exit 0
          }
          # Run a subset of critical tests under MIRI (full suite can be slow)
          echo "Running critical property tests under MIRI..."
          cargo +nightly miri test --all-features --test consensus_property_tests --lib -- --test-threads=1 || {
            echo "‚ö†Ô∏è  MIRI checks found potential undefined behavior (non-blocking)"
            echo "Review MIRI output for details"
            exit 0
          }
          echo "‚úÖ MIRI checks passed"

  build:
    name: Build
    needs: [setup, test, clippy, fmt, docs, security, verify]
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'repository_dispatch' || github.event_name == 'workflow_dispatch') &&
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]'))) &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.skip_verification != 'true' || (always() && (needs.verify.result == 'success' || needs.verify.result == 'skipped'))) &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.skip_tests != 'true' || (always() && (needs.test.result == 'success' || needs.test.result == 'skipped')))
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
          echo "TARGET_CACHE_DIR=$CACHE_ROOT/target/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          fi
      
      - name: Restore target
        run: |
          if [ -d "$TARGET_CACHE_DIR" ] && [ "$(ls -A $TARGET_CACHE_DIR 2>/dev/null)" ]; then
            rsync -a --delete "$TARGET_CACHE_DIR/" ./target/ || true
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Build
        run: cargo build --release
      
      - name: Cache target
        if: always()
        run: |
          if [ -d "./target" ] && [ "$TARGET_CACHE_DIR" != "" ]; then
            mkdir -p "$TARGET_CACHE_DIR" || true
            rsync -a --delete ./target/ "$TARGET_CACHE_DIR/" || true
          fi
      
      - name: Cleanup
        if: always()
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          find "$CACHE_ROOT/cargo" -maxdepth 1 -type d -mtime +1 2>/dev/null | head -n -5 | xargs rm -rf 2>/dev/null || true
          find "$CACHE_ROOT/target" -maxdepth 1 -type d -mtime +1 2>/dev/null | head -n -3 | xargs rm -rf 2>/dev/null || true

  release:
    name: Release
    needs: [build, test, verify]
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch') &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') &&
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]') &&
        !contains(github.event.head_commit.message, '[skip release]'))) &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.skip_verification != 'true' || (always() && (needs.verify.result == 'success' || needs.verify.result == 'skipped'))) &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.skip_tests != 'true' || (always() && (needs.test.result == 'success' || needs.test.result == 'skipped')))
    permissions:
      contents: write
      id-token: write
    env:
      CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Check for breaking changes
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          echo "üîç Checking for breaking changes in commit messages..."
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          else
            COMMIT_RANGE="HEAD~20..HEAD"
          fi
          
          # Check for breaking change indicators
          if git log "$COMMIT_RANGE" --pretty=format:"%s" | grep -qiE "(breaking|!|major|incompatible)"; then
            echo "‚ö†Ô∏è  WARNING: Potential breaking changes detected in commit messages"
            echo "   Consider bumping major or minor version instead of patch"
            git log "$COMMIT_RANGE" --pretty=format:"  - %s" | grep -iE "(breaking|!|major|incompatible)" || true
          else
            echo "‚úÖ No obvious breaking changes detected"
          fi
      
      - name: Check CHANGELOG
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          echo "üìù Checking CHANGELOG.md..."
          if [ ! -f "CHANGELOG.md" ]; then
            echo "‚ö†Ô∏è  CHANGELOG.md not found (optional but recommended)"
            exit 0
          fi
          
          # Check if there's an [Unreleased] section with content
          if grep -q "^## \[Unreleased\]" CHANGELOG.md; then
            UNRELEASED_LINES=$(sed -n '/^## \[Unreleased\]/,/^## /p' CHANGELOG.md | grep -c "^-" || echo "0")
            if [ "$UNRELEASED_LINES" -gt 0 ]; then
              echo "‚úÖ CHANGELOG.md has [Unreleased] entries ($UNRELEASED_LINES items)"
            else
              echo "‚ö†Ô∏è  CHANGELOG.md has [Unreleased] section but no entries"
            fi
          else
            echo "‚ö†Ô∏è  CHANGELOG.md doesn't have [Unreleased] section"
          fi
      
      - name: Determine version
        id: version
        run: |
          # Auto-increment patch version from Cargo.toml
          # Extract only the package version (first version = after [package])
          CURRENT=$(grep -A 10 '^\[package\]' Cargo.toml | grep '^version = ' | head -1 | sed -E 's/^version = "([^"]+)".*/\1/')
          if [ -z "$CURRENT" ]; then
            echo "‚ùå Could not determine current version from Cargo.toml"
            echo "Debug: Looking for version in [package] section"
            grep -A 10 '^\[package\]' Cargo.toml | head -10
            exit 1
          fi
          
          echo "Current version: ${CURRENT}"
          
          # Validate version format (should be X.Y.Z)
          if ! echo "$CURRENT" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "‚ùå Invalid version format: ${CURRENT} (expected X.Y.Z)"
            exit 1
          fi
          
          # Increment patch version (X.Y.Z -> X.Y.(Z+1))
          MAJOR=$(echo "$CURRENT" | cut -d. -f1)
          MINOR=$(echo "$CURRENT" | cut -d. -f2)
          PATCH=$(echo "$CURRENT" | cut -d. -f3)
          
          # Validate components are numeric
          if ! [[ "$MAJOR" =~ ^[0-9]+$ ]] || ! [[ "$MINOR" =~ ^[0-9]+$ ]] || ! [[ "$PATCH" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Version components must be numeric: ${MAJOR}.${MINOR}.${PATCH}"
            exit 1
          fi
          
          PATCH=$((PATCH + 1))
          VERSION="${MAJOR}.${MINOR}.${PATCH}"
          
          # Add -unverified suffix if verification OR tests are skipped
          # (untested counts as unverified)
          # Check if we're in workflow_dispatch mode
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SKIP_VERIFICATION="${{ github.event.inputs.skip_verification }}"
            SKIP_TESTS="${{ github.event.inputs.skip_tests }}"
          else
            SKIP_VERIFICATION="false"
            SKIP_TESTS="false"
          fi
          
          if [ "$SKIP_VERIFICATION" = "true" ] || [ "$SKIP_TESTS" = "true" ]; then
            VERSION_TAG="v${VERSION}-unverified"
            echo "‚ö†Ô∏è  Releasing UNVERIFIED version: ${VERSION_TAG}"
          else
            VERSION_TAG="v${VERSION}"
            echo "‚úÖ Releasing version: ${VERSION_TAG}"
          fi
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
      
      - name: Update Cargo.lock first (before version change)
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          # Remove old lock file and regenerate to ensure latest dependency versions
          rm -f Cargo.lock
          cargo update
          echo "‚úÖ Cargo.lock regenerated with latest dependencies"
          # Verify kani-verifier version
          if grep -q "kani-verifier" Cargo.lock 2>/dev/null; then
            echo "kani-verifier version in Cargo.lock:"
            grep -A 2 "name = \"kani-verifier\"" Cargo.lock | head -3
          fi
      
      - name: Update version in Cargo.toml
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "Updating package version to ${VERSION}"
          
          # Use awk to update only the version in [package] section
          export VERSION
          awk -v ver="$VERSION" '
            /^\[package\]/ { in_package = 1; print; next }
            /^\[/ { in_package = 0 }
            in_package && /^version = / { 
              print "version = \"" ver "\""
              next
            }
            { print }
          ' Cargo.toml > Cargo.toml.tmp && mv Cargo.toml.tmp Cargo.toml
          
          echo "‚úÖ Updated Cargo.toml to version ${VERSION}"
          echo "Package version line:"
          grep "^version = " Cargo.toml | head -1
          echo "Verifying kani-verifier is unchanged:"
          grep -A 1 "\[dependencies.kani-verifier\]" Cargo.toml
      
      - name: Regenerate Cargo.lock after version change
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          # Regenerate lock file after version change to ensure consistency
          rm -f Cargo.lock
          cargo update
          echo "‚úÖ Cargo.lock regenerated after version update"
          
          # Verify the package version in Cargo.lock matches
          if grep -q "name = \"bllvm-consensus\"" Cargo.lock 2>/dev/null; then
            echo "Package version in Cargo.lock:"
            grep -A 1 "name = \"bllvm-consensus\"" Cargo.lock | grep "version" | head -1
          fi
      
      - name: Pre-release smoke test
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          echo "üß™ Running smoke tests with new version..."
          # Quick compile check
          cargo check --quiet || {
            echo "‚ùå Compilation failed after version update"
            exit 1
          }
          # Run a quick test to ensure nothing broke
          cargo test --lib --quiet -- --test-threads=1 || {
            echo "‚ùå Tests failed after version update"
            exit 1
          }
          echo "‚úÖ Smoke tests passed"
      
      - name: Commit Cargo.toml changes
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Only commit Cargo.toml (Cargo.lock is ignored for libraries)
          git add Cargo.toml
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit in Cargo.toml"
          else
            git commit -m "Bump version to ${{ steps.version.outputs.version }} for release [skip ci]" || true
            
            # Push if REPO_ACCESS_TOKEN is available
            if [ -n "${{ secrets.REPO_ACCESS_TOKEN }}" ]; then
              git remote set-url origin "https://${{ secrets.REPO_ACCESS_TOKEN }}@github.com/${{ github.repository }}.git"
              git push origin HEAD:${{ github.ref }} || true
            else
              echo "‚ö†Ô∏è  REPO_ACCESS_TOKEN not set, skipping push"
            fi
          fi
      
      - name: Check for crates.io token
        run: |
          if [ -z "${CARGO_REGISTRY_TOKEN:-}" ]; then
            echo "‚ö†Ô∏è  CARGO_REGISTRY_TOKEN not set, skipping crate publication"
            echo "   Set CARGO_REGISTRY_TOKEN secret to enable crate publishing"
            exit 0
          fi
      
      - name: Configure cargo for crates.io
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          cargo login "${CARGO_REGISTRY_TOKEN}"
      
      - name: Verify package version before packaging
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          EXPECTED_VERSION="${{ steps.version.outputs.version }}"
          ACTUAL_VERSION=$(grep -A 10 '^\[package\]' Cargo.toml | grep '^version = ' | head -1 | sed -E 's/^version = "([^"]+)".*/\1/')
          echo "Expected version: ${EXPECTED_VERSION}"
          echo "Actual version in Cargo.toml: ${ACTUAL_VERSION}"
          if [ "$ACTUAL_VERSION" != "$EXPECTED_VERSION" ]; then
            echo "‚ùå Version mismatch! Expected ${EXPECTED_VERSION} but found ${ACTUAL_VERSION}"
            exit 1
          fi
          echo "‚úÖ Version matches: ${ACTUAL_VERSION}"
      
      - name: Verify package
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          cargo package --list
      
      - name: Dry-run publish
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          cargo publish --dry-run
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
      
      - name: Check if version already exists
        if: env.CARGO_REGISTRY_TOKEN != ''
        id: check-version
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          CRATE_NAME=$(grep -E '^name = ' Cargo.toml | sed -E 's/^name = "([^"]+)".*/\1/')
          
          echo "üîç Checking if ${CRATE_NAME} v${VERSION} already exists on crates.io..."
          
          # Use crates.io API to check if version exists (more reliable than cargo search)
          # The API returns versions in the "versions" array
          # Retry up to 3 times with exponential backoff
          API_RESPONSE=""
          for i in 1 2 3; do
            API_RESPONSE=$(curl -s --max-time 10 "https://crates.io/api/v1/crates/${CRATE_NAME}/versions" 2>/dev/null || echo "")
            if [ -n "$API_RESPONSE" ] && ! echo "$API_RESPONSE" | grep -q '"detail"'; then
              break
            fi
            if [ $i -lt 3 ]; then
              echo "‚ö†Ô∏è  API check attempt $i failed, retrying in $((i*2)) seconds..."
              sleep $((i*2))
            fi
          done
          
          if [ -z "$API_RESPONSE" ] || echo "$API_RESPONSE" | grep -q '"detail"'; then
            echo "‚ö†Ô∏è  Could not check crates.io API (crate may not exist yet), using cargo search as fallback"
            # Fallback to cargo search - check all versions
            SEARCH_OUTPUT=$(cargo search "$CRATE_NAME" --limit 100 2>/dev/null || echo "")
            if echo "$SEARCH_OUTPUT" | grep -qE "\"${CRATE_NAME}\".*\"${VERSION}\""; then
              echo "exists=true" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è  Version ${VERSION} already published for ${CRATE_NAME} (found via cargo search)"
            else
              echo "exists=false" >> $GITHUB_OUTPUT
              echo "‚úÖ Version ${VERSION} not yet published for ${CRATE_NAME} (cargo search)"
            fi
          else
            # Show existing versions for debugging
            echo "üìã Existing versions on crates.io:"
            if command -v jq &> /dev/null; then
              echo "$API_RESPONSE" | jq -r ".versions[].num" | head -5
            else
              echo "$API_RESPONSE" | grep -o '"num":"[^"]*"' | sed 's/"num":"\(.*\)"/\1/' | head -5
            fi
            echo ""
            
            # Parse JSON to check if version exists (using jq if available, or grep as fallback)
            if command -v jq &> /dev/null; then
              VERSION_EXISTS=$(echo "$API_RESPONSE" | jq -r ".versions[] | select(.num == \"${VERSION}\") | .num" | head -1)
              if [ "$VERSION_EXISTS" = "$VERSION" ]; then
                echo "exists=true" >> $GITHUB_OUTPUT
                echo "‚ö†Ô∏è  Version ${VERSION} already published for ${CRATE_NAME} (found via API)"
              else
                echo "exists=false" >> $GITHUB_OUTPUT
                echo "‚úÖ Version ${VERSION} not yet published for ${CRATE_NAME} (API check)"
              fi
            else
              # Fallback: grep for version in JSON
              if echo "$API_RESPONSE" | grep -q "\"num\":\"${VERSION}\""; then
                echo "exists=true" >> $GITHUB_OUTPUT
                echo "‚ö†Ô∏è  Version ${VERSION} already published for ${CRATE_NAME} (found via grep)"
              else
                echo "exists=false" >> $GITHUB_OUTPUT
                echo "‚úÖ Version ${VERSION} not yet published for ${CRATE_NAME} (grep check)"
              fi
            fi
          fi
          
          echo ""
          echo "üìä Version check result: ${{ steps.check-version.outputs.exists }}"
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
      
      - name: Publish to crates.io
        if: env.CARGO_REGISTRY_TOKEN != ''
        id: publish
        continue-on-error: true
        run: |
          set +e
          VERSION="${{ steps.version.outputs.version }}"
          CRATE_NAME=$(grep -E '^name = ' Cargo.toml | sed -E 's/^name = "([^"]+)".*/\1/')
          
          echo "üîç Publish Debug Info:"
          echo "  Version: ${VERSION}"
          echo "  Crate: ${CRATE_NAME}"
          echo "  Version exists check: ${{ steps.check-version.outputs.exists }}"
          
          # Verify Cargo.toml version matches expected version
          ACTUAL_VERSION=$(grep -A 10 '^\[package\]' Cargo.toml | grep '^version = ' | head -1 | sed -E 's/^version = "([^"]+)".*/\1/')
          echo "  Cargo.toml version: ${ACTUAL_VERSION}"
          
          if [ "$ACTUAL_VERSION" != "$VERSION" ]; then
            echo "‚ùå CRITICAL: Cargo.toml version (${ACTUAL_VERSION}) does not match expected version (${VERSION})"
            echo "‚ùå Cannot publish - version mismatch. Check if 'Update version in Cargo.toml' step ran successfully."
            echo "published=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Skip if version already exists
          if [ "${{ steps.check-version.outputs.exists }}" = "true" ]; then
            echo "‚ö†Ô∏è  Version ${VERSION} already exists on crates.io, skipping publish"
            echo "published=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo ""
          echo "üì¶ Publishing ${CRATE_NAME} v${VERSION} to crates.io..."
          echo "Running: cargo publish --token [REDACTED]"
          
          PUBLISH_OUTPUT=$(cargo publish --token "${CARGO_REGISTRY_TOKEN}" 2>&1)
          PUBLISH_EXIT_CODE=$?
          
          echo ""
          echo "üìã Publish Output:"
          echo "$PUBLISH_OUTPUT"
          echo ""
          
          if [ $PUBLISH_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Successfully published ${CRATE_NAME} v${VERSION}"
            echo "published=true" >> $GITHUB_OUTPUT
            echo "Waiting 30 seconds for crates.io to index..."
            sleep 30
            echo "‚úÖ Publish complete - version should be available on crates.io"
          else
            # Check if error is due to version already existing
            if echo "$PUBLISH_OUTPUT" | grep -qi "already exists"; then
              echo "‚ö†Ô∏è  Version ${VERSION} already exists on crates.io (detected during publish)"
              echo "published=false" >> $GITHUB_OUTPUT
              # Update exists status since we confirmed it exists
              echo "exists=true" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "‚ùå Failed to publish ${CRATE_NAME} v${VERSION}"
              echo "Exit code: $PUBLISH_EXIT_CODE"
              echo "Error output:"
              echo "$PUBLISH_OUTPUT"
              echo ""
              echo "‚ö†Ô∏è  Publish failed - check error output above"
              echo "published=false" >> $GITHUB_OUTPUT
              # Don't exit with error code - let workflow continue
              exit 0
            fi
          fi
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

      - name: Final verification - check if version exists on crates.io
        if: env.CARGO_REGISTRY_TOKEN != ''
        id: final-verify
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          CRATE_NAME=$(grep -E '^name = ' Cargo.toml | sed -E 's/^name = "([^"]+)".*/\1/')
          
          echo "üîç Final verification: Checking if ${CRATE_NAME} v${VERSION} exists on crates.io..."
          
          # Wait a bit for crates.io to index if it was just published
          sleep 5
          
          # Use crates.io API to verify version exists
          API_RESPONSE=$(curl -s --max-time 10 "https://crates.io/api/v1/crates/${CRATE_NAME}/versions" 2>/dev/null || echo "")
          
          if [ -n "$API_RESPONSE" ] && ! echo "$API_RESPONSE" | grep -q '"detail"'; then
            if command -v jq &> /dev/null; then
              VERSION_EXISTS=$(echo "$API_RESPONSE" | jq -r ".versions[] | select(.num == \"${VERSION}\") | .num" | head -1)
              if [ "$VERSION_EXISTS" = "$VERSION" ]; then
                echo "‚úÖ Verified: Version ${VERSION} exists on crates.io"
                echo "exists=true" >> $GITHUB_OUTPUT
              else
                echo "‚ö†Ô∏è  Version ${VERSION} not found on crates.io (may need more time to index)"
                echo "exists=false" >> $GITHUB_OUTPUT
              fi
            else
              if echo "$API_RESPONSE" | grep -q "\"num\":\"${VERSION}\""; then
                echo "‚úÖ Verified: Version ${VERSION} exists on crates.io"
                echo "exists=true" >> $GITHUB_OUTPUT
              else
                echo "‚ö†Ô∏è  Version ${VERSION} not found on crates.io (may need more time to index)"
                echo "exists=false" >> $GITHUB_OUTPUT
              fi
            fi
          else
            echo "‚ö†Ô∏è  Could not verify via API, assuming version check from earlier step is correct"
            echo "exists=${{ steps.check-version.outputs.exists }}" >> $GITHUB_OUTPUT
          fi
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

      - name: Create git tag
        run: |
          VERSION_TAG="${{ steps.version.outputs.version_tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if tag already exists
          if git rev-parse "$VERSION_TAG" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Tag ${VERSION_TAG} already exists, skipping tag creation"
          else
            git tag -a "$VERSION_TAG" -m "Release ${VERSION_TAG}"
            git push origin "$VERSION_TAG"
            echo "‚úÖ Created and pushed tag ${VERSION_TAG}"
          fi
      
      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          VERSION_TAG="${{ steps.version.outputs.version_tag }}"
          CRATE_NAME=$(grep -E '^name = ' Cargo.toml | sed -E 's/^name = "([^"]+)".*/\1/')
          DESCRIPTION=$(grep -E '^description = ' Cargo.toml | sed -E 's/^description = "([^"]+)".*/\1/' || echo "Bitcoin consensus implementation")
          
          # Get commit range for this release
          if [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
            COMMIT_RANGE="${{ github.event.before }}..${{ github.sha }}"
            COMMIT_COUNT=$(git rev-list --count "$COMMIT_RANGE" 2>/dev/null || echo "?")
          else
            COMMIT_RANGE="HEAD~10..HEAD"
            COMMIT_COUNT="?"
          fi
          
          cat > /tmp/release_notes.md << EOF
          ## $VERSION_TAG
          
          **$DESCRIPTION**
          
          ### üì¶ Installation
          
          Add to your \`Cargo.toml\`:
          
          \`\`\`toml
          [dependencies]
          $CRATE_NAME = "$VERSION"
          \`\`\`
          
          Or install via cargo:
          
          \`\`\`bash
          cargo add $CRATE_NAME@$VERSION
          \`\`\`
          
          ### üîó Links
          
          EOF
          
          # Add links conditionally based on publish status
          PUBLISH_STATUS="${{ steps.publish.outputs.published }}"
          # Use final verification if available (more reliable), otherwise use initial check
          FINAL_EXISTS="${{ steps.final-verify.outputs.exists }}"
          INITIAL_EXISTS="${{ steps.check-version.outputs.exists }}"
          if [ "$FINAL_EXISTS" = "true" ] || [ "$FINAL_EXISTS" = "false" ]; then
            VERSION_EXISTS="$FINAL_EXISTS"
          else
            VERSION_EXISTS="$INITIAL_EXISTS"
          fi
          
          # Check if version exists on crates.io (either just published or already existed)
          if [ "$PUBLISH_STATUS" = "true" ] || [ "$VERSION_EXISTS" = "true" ]; then
            echo "- **Crates.io**: [${CRATE_NAME} v${VERSION}](https://crates.io/crates/${CRATE_NAME}/${VERSION})" >> /tmp/release_notes.md
            echo "- **Documentation**: [docs.rs/${CRATE_NAME}/${VERSION}](https://docs.rs/${CRATE_NAME}/${VERSION})" >> /tmp/release_notes.md
          else
            echo "- **Crates.io**: ‚ö†Ô∏è  Not published (publish failed or was skipped)" >> /tmp/release_notes.md
            echo "- **Documentation**: Not available (crate not published)" >> /tmp/release_notes.md
          fi
          echo "- **Repository**: [GitHub](https://github.com/${{ github.repository }})" >> /tmp/release_notes.md
          
          # Determine publish status message
          PUBLISH_STATUS_MSG="‚ùå Failed or skipped"
          if [ "$PUBLISH_STATUS" = "true" ]; then
            PUBLISH_STATUS_MSG="‚úÖ Yes"
          elif [ "$VERSION_EXISTS" = "true" ]; then
            PUBLISH_STATUS_MSG="‚ö†Ô∏è  Already exists"
          fi
          
          # Get repository name for commit history link
          REPO_NAME="${{ github.repository }}"
          
          cat >> /tmp/release_notes.md << EOF
          
          ### üìù Changes
          
          This release includes $COMMIT_COUNT commits since the last release.
          
          **Published to crates.io**: $PUBLISH_STATUS_MSG
          
          See [full commit history](https://github.com/${REPO_NAME}/compare/${COMMIT_RANGE}) for details.
          EOF
          
          # Add warning only if publish failed AND version doesn't exist
          if [ "$PUBLISH_STATUS" != "true" ] && [ "$VERSION_EXISTS" != "true" ]; then
            echo "" >> /tmp/release_notes.md
            echo "‚ö†Ô∏è  **Note**: This version was not published to crates.io. Check the workflow logs for details." >> /tmp/release_notes.md
          fi
          
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          cat /tmp/release_notes.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Download attestation artifacts
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event.inputs.skip_verification != 'true' && github.event.inputs.skip_tests != 'true') }}
        uses: actions/download-artifact@v4
        with:
          pattern: '*-attestation-data'
          merge-multiple: true
          path: attestation-data
      
      - name: Collect build metadata
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event.inputs.skip_verification != 'true' && github.event.inputs.skip_tests != 'true') }}
        id: metadata
        run: |
          # Get toolchain versions
          RUSTC_VERSION=$(rustc --version | cut -d' ' -f2)
          CARGO_VERSION=$(cargo --version | cut -d' ' -f2)
          
          # Get CBMC version from Kani (if available)
          CBMC_VERSION=""
          if command -v kani &> /dev/null; then
            CBMC_VERSION=$(kani --version 2>&1 | grep -i cbmc | head -1 | sed -E 's/.*cbmc[^0-9]*([0-9.]+).*/\1/' || echo "")
          fi
          if [ -z "$CBMC_VERSION" ]; then
            CBMC_VERSION="unknown"
          fi
          
          # Hash Cargo.lock
          CARGO_LOCK_HASH=$(sha256sum Cargo.lock | cut -d' ' -f1)
          
          # Check if debug assertions are enabled (check Cargo.toml or build flags)
          DEBUG_ASSERTIONS="false"
          if grep -q "debug-assertions = true" Cargo.toml 2>/dev/null; then
            DEBUG_ASSERTIONS="true"
          fi
          
          # Extract Kani data from artifacts
          KANI_VERIFIED="false"
          KANI_PROOFS="0"
          KANI_OUTPUT_HASH=""
          if [ -f "attestation-data/kani_output.txt" ]; then
            KANI_VERIFIED="true"
            KANI_OUTPUT_HASH=$(sha256sum attestation-data/kani_output.txt | cut -d' ' -f1)
            # Count proofs from output (approximate)
            KANI_PROOFS=$(grep -c "Checking harness" attestation-data/kani_output.txt 2>/dev/null || echo "0")
            if [ "$KANI_PROOFS" = "0" ]; then
              # Fallback: count from tier (main branch runs all proofs)
              KANI_PROOFS="195"
            fi
          fi
          
          # Extract test coverage from XML
          TEST_COVERAGE_PCT="0.00"
          if [ -f "attestation-data/coverage/cobertura.xml" ]; then
            TEST_COVERAGE_PCT=$(grep -oP 'line-rate="\K[0-9.]+' attestation-data/coverage/cobertura.xml | head -1 | awk '{printf "%.2f", $1 * 100}')
          fi
          
          # Extract unit tests hash
          UNIT_TESTS_HASH=""
          if [ -f "attestation-data/test_output.txt" ]; then
            UNIT_TESTS_HASH=$(sha256sum attestation-data/test_output.txt | cut -d' ' -f1)
          fi
          
          # Output all metadata
          echo "kani_verified=$KANI_VERIFIED" >> $GITHUB_OUTPUT
          echo "kani_proofs=$KANI_PROOFS" >> $GITHUB_OUTPUT
          echo "kani_output_hash=$KANI_OUTPUT_HASH" >> $GITHUB_OUTPUT
          echo "test_coverage_percent=$TEST_COVERAGE_PCT" >> $GITHUB_OUTPUT
          echo "unit_tests_hash=$UNIT_TESTS_HASH" >> $GITHUB_OUTPUT
          echo "debug_assertions_enabled=$DEBUG_ASSERTIONS" >> $GITHUB_OUTPUT
          echo "rustc_version=$RUSTC_VERSION" >> $GITHUB_OUTPUT
          echo "cbmc_version=$CBMC_VERSION" >> $GITHUB_OUTPUT
          echo "cargo_version=$CARGO_VERSION" >> $GITHUB_OUTPUT
          echo "cargo_lock_hash=$CARGO_LOCK_HASH" >> $GITHUB_OUTPUT
          
          echo "üìã Build Metadata:"
          echo "  Kani verified: $KANI_VERIFIED"
          echo "  Kani proofs: $KANI_PROOFS"
          echo "  Kani output hash: $KANI_OUTPUT_HASH"
          echo "  Test coverage: ${TEST_COVERAGE_PCT}%"
          echo "  Unit tests hash: $UNIT_TESTS_HASH"
          echo "  Debug assertions: $DEBUG_ASSERTIONS"
          echo "  rustc version: $RUSTC_VERSION"
          echo "  CBMC version: $CBMC_VERSION"
          echo "  cargo version: $CARGO_VERSION"
          echo "  Cargo.lock hash: $CARGO_LOCK_HASH"
      
      - name: Create build metadata JSON
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event.inputs.skip_verification != 'true' && github.event.inputs.skip_tests != 'true') }}
        run: |
          # Create metadata JSON file for artifact storage
          cat > build-metadata.json << EOF
          {
            "kani_verified": ${{ steps.metadata.outputs.kani_verified == 'true' && 'true' || 'false' }},
            "kani_proofs": ${{ steps.metadata.outputs.kani_proofs }},
            "kani_output_hash": "${{ steps.metadata.outputs.kani_output_hash }}",
            "test_coverage_percent": ${{ steps.metadata.outputs.test_coverage_percent }},
            "unit_tests_hash": "${{ steps.metadata.outputs.unit_tests_hash }}",
            "debug_assertions_enabled": ${{ steps.metadata.outputs.debug_assertions_enabled == 'true' && 'true' || 'false' }},
            "rustc_version": "${{ steps.metadata.outputs.rustc_version }}",
            "cbmc_version": "${{ steps.metadata.outputs.cbmc_version }}",
            "cargo_version": "${{ steps.metadata.outputs.cargo_version }}",
            "cargo_lock_hash": "${{ steps.metadata.outputs.cargo_lock_hash }}"
          }
          EOF
          cat build-metadata.json
      
      - name: Upload build metadata
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event.inputs.skip_verification != 'true' && github.event.inputs.skip_tests != 'true') }}
        uses: actions/upload-artifact@v4
        with:
          name: build-metadata
          path: build-metadata.json
          retention-days: 365
      
      - name: Attest build provenance
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event.inputs.skip_verification != 'true' && github.event.inputs.skip_tests != 'true') }}
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: "bllvm-consensus"
          subject-digest: "sha256:${{ steps.metadata.outputs.cargo_lock_hash }}"
          push-to-registry: false
          show-summary: true
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version_tag }}
          name: Release ${{ steps.version.outputs.version_tag }}
          body: ${{ steps.release_notes.outputs.notes }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
